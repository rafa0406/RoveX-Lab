<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RoverX Lab</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Inter', sans-serif;
            background-color: #111827;
            color: #e5e7eb;
            touch-action: none;
        }

        canvas {
            display: block;
        }

        .info-panel {
            position: absolute;
            padding: 10px 15px;
            background-color: rgba(0, 0, 0, 0.6);
            border-radius: 8px;
            color: white;
            font-size: 14px;
            z-index: 10;
        }

        #log-window {
            position: absolute;
            top: 10px;
            left: 10px;
            width: 300px;
            height: 350px;
            background-color: rgba(0, 0, 0, 0.7);
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: #e5e7eb;
            font-family: monospace;
            font-size: 12px;
            padding: 10px;
            overflow-y: auto;
            z-index: 20;
        }

        .log-message {
            margin-bottom: 5px;
            word-break: break-all;
        }

        .log-info {
            color: #a5b4fc;
        }

        .log-success {
            color: #6ee7b7;
        }

        .log-error {
            color: #f87171;
        }

        .log-debug {
            color: #facc15;
        }

        .control-btn {
            background-color: rgba(31, 41, 55, 0.7);
            border: 1px solid rgba(75, 85, 99, 0.8);
            color: white;
            width: 60px;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 9999px;
            transition: background-color 0.2s;
            user-select: none;
        }

            .control-btn:active {
                background-color: rgba(75, 85, 99, 0.9);
            }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
</head>
<body>
    <div id="log-window"></div>
    <div id="info" class="info-panel top-10 right-10"><strong>RoverX Lab</strong><br>Statut : v1.2 Stable</div>
    <div id="controls-info" class="info-panel bottom-10 left-10">Contrôles actifs</div>
    <div id="controls-ui" class="absolute bottom-24 right-8 grid grid-cols-3 grid-rows-2 gap-4 w-52 z-10">
        <button id="btn-up" class="control-btn col-start-2 row-start-1"><svg class="w-8 h-8" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 15l7-7 7 7"></path></svg></button>
        <button id="btn-left" class="control-btn col-start-1 row-start-2"><svg class="w-8 h-8" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"></path></svg></button>
        <button id="btn-right" class="control-btn col-start-3 row-start-2"><svg class="w-8 h-8" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path></svg></button>
        <button id="btn-down" class="control-btn col-start-2 row-start-2"><svg class="w-8 h-8" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg></button>
    </div>

    <script type="importmap">{ "imports": { "three": "https://cdn.jsdelivr.net/npm/three@0.165.0/build/three.module.js" } }</script>

    <script type="module">
        import * as THREE from 'three';

        // --- GLOBAL SCOPE ---
        let scene, camera, renderer, rover, ground, raycaster, logWindow;
        const obstacles = [];
        const keys = { ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false };
        const clock = new THREE.Clock();

        function logMessage(message, level = 'info') {
            if (!logWindow) logWindow = document.getElementById('log-window');
            if(logWindow) {
                const p = document.createElement('p');
                p.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
                p.className = `log-message log-${level}`;
                logWindow.appendChild(p);
                logWindow.scrollTop = logWindow.scrollHeight;
            }
        }

        const Perlin = {
            rand_vect: function(){ let theta = Math.random() * 2 * Math.PI; return {x: Math.cos(theta), y: Math.sin(theta)}; },
            dot_prod_grid: function(x, y, vx, vy){
                let g_vect; let d_vect = {x: x - vx, y: y - vy};
                if (this.G[[vx,vy]]) { g_vect = this.G[[vx,vy]]; } else { g_vect = this.rand_vect(); this.G[[vx,vy]] = g_vect; }
                return d_vect.x * g_vect.x + d_vect.y * g_vect.y;
            },
            smootherstep: function(x){ return 6*x**5 - 15*x**4 + 10*x**3; },
            interp: function(x, a, b){ return a + this.smootherstep(x) * (b-a); },
            seed: function(){ this.G = {}; },
            get: function(x, y) {
                if (!this.G) { this.seed(); }
                let xf = Math.floor(x); let yf = Math.floor(y);
                let tl = this.dot_prod_grid(x, y, xf,   yf); let tr = this.dot_prod_grid(x, y, xf+1, yf);
                let bl = this.dot_prod_grid(x, y, xf,   yf+1); let br = this.dot_prod_grid(x, y, xf+1, yf+1);
                let xt = this.interp(x-xf, tl, tr); let xb = this.interp(x-xf, bl, br);
                return this.interp(y-yf, xt, xb);
            }
        };

        window.addEventListener('load', () => {
            logMessage("Événement 'window.load' déclenché.", 'debug');
            init();
        });

        function init() {
            try {
                logMessage("Initialisation du simulateur...");
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x1a2a3a);
                scene.fog = new THREE.Fog(0x1a2a3a, 20, 150);
                camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                camera.position.set(0, 5, 10);
                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(window.devicePixelRatio);
                renderer.shadowMap.enabled = true;
                document.body.appendChild(renderer.domElement);
                const ambientLight = new THREE.AmbientLight(0x606080, 2);
                scene.add(ambientLight);
                const directionalLight = new THREE.DirectionalLight(0xffffff, 2.5);
                directionalLight.position.set(50, 50, 25);
                directionalLight.castShadow = true;
                directionalLight.shadow.camera.top = 50; directionalLight.shadow.camera.bottom = -50;
                directionalLight.shadow.camera.left = -50; directionalLight.shadow.camera.right = 50;
                directionalLight.shadow.mapSize.width = 2048; directionalLight.shadow.mapSize.height = 2048;
                scene.add(directionalLight);
                raycaster = new THREE.Raycaster();
                logMessage('Lancement de la génération du terrain...', 'info');
                generateTerrain();
            } catch (error) {
                logMessage(`Erreur critique durant init: ${error.message}`, 'error');
                console.error(error);
            }
        }

        function generateTerrain() {
            const noiseGenerator = Perlin;
            noiseGenerator.seed();
            const terrainSize = 200, terrainSegments = 200;
            const groundGeometry = new THREE.PlaneGeometry(terrainSize, terrainSize, terrainSegments, terrainSegments);
            const positions = groundGeometry.attributes.position;
            const totalVertices = positions.count;
            let currentVertex = 0;
            const verticesPerFrame = 2500;
            let lastLoggedProgress = -1;
            logMessage('Démarrage de la boucle de génération...', 'debug');
            function generationStep() {
                const limit = Math.min(currentVertex + verticesPerFrame, totalVertices);
                for (let i = currentVertex; i < limit; i++) {
                    const x = positions.getX(i); const y = positions.getY(i);
                    let height = 0, freq = 2.5 / terrainSize, amp = 12;
                    for (let j = 0; j < 4; j++) {
                        height += noiseGenerator.get(x * freq, y * freq) * amp;
                        freq *= 2.5; amp *= 0.4;
                    }
                    positions.setZ(i, height);
                }
                currentVertex = limit;
                const progress = Math.floor((currentVertex / totalVertices) * 10) * 10;
                if (progress > lastLoggedProgress) {
                    logMessage(`Génération du terrain: ${progress}%`, 'info');
                    lastLoggedProgress = progress;
                }
                if (currentVertex < totalVertices) { requestAnimationFrame(generationStep); } else { onGenerationComplete(); }
            }
            function onGenerationComplete() {
                logMessage('Finalisation du maillage...', 'info');
                groundGeometry.attributes.position.needsUpdate = true;
                groundGeometry.computeVertexNormals();
                const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x5a6a7a, roughness: 0.9, side: THREE.DoubleSide });
                ground = new THREE.Mesh(groundGeometry, groundMaterial);
                ground.rotation.x = -Math.PI / 2;
                ground.receiveShadow = true;
                scene.add(ground);
                logMessage('Terrain généré avec succès.', 'success');
                onTerrainReady();
            }
            requestAnimationFrame(generationStep);
        }

        function onTerrainReady() {
            logMessage('Préparation des objets de la simulation...');
            createRover();
            placeObstacles();
            setupControls();
            logMessage('Simulation démarrée. Prêt à explorer !', 'success');
            animate();
        }

        function createRover() {
            rover = new THREE.Group();
            const body = new THREE.Mesh(new THREE.BoxGeometry(1.5, 0.5, 2.5), new THREE.MeshStandardMaterial({ color: 0xe0e0e0, roughness: 0.4 }));
            body.name = "roverBody"; body.castShadow = true; rover.add(body);
            const wheelGeom = new THREE.CylinderGeometry(0.4, 0.4, 0.2, 16);
            const wheelMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
            const wheelPos = [[0.9, -0.1, 1], [-0.9, -0.1, 1], [0.9, -0.1, -1], [-0.9, -0.1, -1]];
            wheelPos.forEach(p => {
                const wheel = new THREE.Mesh(wheelGeom, wheelMat);
                wheel.rotation.z = Math.PI / 2; wheel.position.set(p[0], p[1], p[2]);
                wheel.castShadow = true; rover.add(wheel);
            });
            rover.position.set(0, 30, 0);
            scene.add(rover);
            logMessage('Rover créé à la position (0, 30, 0).');
        }

        function placeObstacles() {
            const rockGeom = new THREE.DodecahedronGeometry(1, 0);
            const rockMat = new THREE.MeshStandardMaterial({ color: 0x8c7b6a, roughness: 0.9 });
            const safeZone = { width: 15, length: 15 };
            const numObstacles = 40;

            while (obstacles.length < numObstacles) {
                let x, z;
                do {
                    x = (Math.random() - 0.5) * 180;
                    z = (Math.random() - 0.5) * 180;
                } while (Math.abs(x) < safeZone.width / 2 && Math.abs(z) < safeZone.length / 2);

                const pos = new THREE.Vector3(x, 50, z);
                raycaster.set(pos, new THREE.Vector3(0, -1, 0));
                const intersects = raycaster.intersectObject(ground);

                if (intersects.length > 0) {
                    const groundPoint = intersects[0].point;

                    const rock = new THREE.Mesh(rockGeom, rockMat);
                    const scale = Math.random() * 0.8 + 0.4;
                    rock.scale.set(scale, scale, scale);

                    // --- NOUVELLE LOGIQUE DE PLACEMENT ---
                    // 1. Placer le centre du rocher sur le sol
                    rock.position.copy(groundPoint);

                    // 2. L'enfouir d'un montant proportionnel à sa taille
                    const buryAmount = (Math.random() * 0.3 + 0.2) * scale; // Enfoui entre 20% et 50% de sa taille
                    rock.position.y -= buryAmount;

                    rock.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
                    rock.castShadow = true;
                    rock.receiveShadow = true;
                    scene.add(rock);
                    obstacles.push(rock);
                }
            }
            logMessage(`${obstacles.length} rochers placés avec succès.`);
        }

        function setupControls() {
            document.addEventListener('keydown', (e) => { if(keys[e.key] !== undefined) { e.preventDefault(); keys[e.key] = true; }});
            document.addEventListener('keyup', (e) => { if(keys[e.key] !== undefined) { e.preventDefault(); keys[e.key] = false; }});
            const controls = { 'btn-up': 'ArrowUp', 'btn-down': 'ArrowDown', 'btn-left': 'ArrowLeft', 'btn-right': 'ArrowRight' };
            for (const [id, key] of Object.entries(controls)) {
                const btn = document.getElementById(id);
                const press = (e) => { e.preventDefault(); keys[key] = true; };
                const release = (e) => { e.preventDefault(); keys[key] = false; };
                btn.addEventListener('mousedown', press); btn.addEventListener('mouseup', release);
                btn.addEventListener('mouseleave', release);
                btn.addEventListener('touchstart', press, { passive: false });
                btn.addEventListener('touchend', release);
            }
            logMessage('Contrôles initialisés.');
        }

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            if (rover && ground) updateRoverPhysics(delta);
            if (rover && camera) {
                 const cameraOffset = new THREE.Vector3(0, 5, 12).applyQuaternion(rover.quaternion);
                 camera.position.lerp(rover.position.clone().add(cameraOffset), 0.1);
                 camera.lookAt(rover.position);
            }
            renderer.render(scene, camera);
        }

        function updateRoverPhysics(delta) {
            const speed = 10 * delta; const rotSpeed = 2 * delta;
            if (keys.ArrowLeft) rover.rotation.y += rotSpeed;
            if (keys.ArrowRight) rover.rotation.y -= rotSpeed;
            let moveDir = 0;
            if (keys.ArrowUp) moveDir = -1; if (keys.ArrowDown) moveDir = 1;
            const moveVec = new THREE.Vector3(0, 0, moveDir * speed).applyQuaternion(rover.quaternion);
            moveVec.y = 0;

            let collision = false;
            const roverBody = rover.getObjectByName("roverBody");
            if (roverBody && moveDir !== 0) {
                const futureBox = new THREE.Box3().setFromObject(roverBody);
                futureBox.translate(moveVec);
                for(const obs of obstacles) {
                    if (futureBox.intersectsBox(new THREE.Box3().setFromObject(obs))) {
                        collision = true; break;
                    }
                }
            }
            if (!collision) { rover.position.add(moveVec); }

            raycaster.set(rover.position.clone().add(new THREE.Vector3(0, 20, 0)), new THREE.Vector3(0, -1, 0));
            const intersects = raycaster.intersectObject(ground);
            if (intersects.length > 0) {
                const targetY = intersects[0].point.y + 0.35;
                rover.position.y += (targetY - rover.position.y) * 0.1;
            }

            if (!collision && moveDir !== 0) {
                rover.children.forEach(c => {
                    if(c.geometry.type === 'CylinderGeometry') { c.rotation.x -= moveDir * 0.2; }
                });
            }
        }

        window.addEventListener('resize', () => {
            if (camera && renderer) {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }
        });
    </script>
</body>
</html>
